# Computer Systems Fundamentals (COMP1521)

## Term Taken: 23T2

### Enjoyment: 5/5, Usefulness: 4/5, Manageability: 4/5



#### Summary
I thought this course was run really well in 23T2 and was a great introduction to systems programming. The tutors provide a lot of support and the content, particularly the second half of the course, is super interesting.

The first half of the course is all about translating `C` code into a simplified subset of MIPS assembly, which is a bit tedious but is a good way to learn about how `C` code is actually executed.

The second half of the course is all about files, bit maniupulation, and some fundamentals regarding processes, concurrency and virtual memory. Although this content was significantly harder than the first half, I thought it was really rewarding to learn, and has made me excited to take further low-level courses like Operating Systems.


#### Lectures
Unless you have significant low-level programming experience, this is probably the only first-year course where I would recommend fully watching the lectures or attending them live.

For the first half of the term, I attended the live lectures with my friends, and after Flex Week, I ended up reading the slides and taking notes about the concepts in my own time. I would also recommend taking notes for the second half of the course, as the content is a lot more complex and it's easy to get lost if you don't have a good understanding of the fundamentals.

#### Tutorials
I attended a range of tutorials for this course and thought that they were helpful for consolidating the content from the lectures. For me, the MIPS assembly content didn't fully click until week 3, and the tutorials helped me get a better understanding of the content.

During weeks where we were working on assignments, the tutors would often go through the assignment spec and give us some tips on how to approach the problem.

#### Weekly Assessments
The compulsory lab exercises can range from easy to slightly challenging, and since this was the first course I took that had autotests, I found them to be really helpful and a good way of making the labs fun. The labs were also a great way to get a better understanding of the content from the lectures.

Some of the challenge exercises were extremely time consuming and difficult, so I ended up skipping them for the most part; however, if you are willing to spend extra time on the course, I would recommend giving them a go.

The weekly tests are significantly easier than the lab exercises, and even despite the time constraint, I wouldn't worry too much about them. Most people I know finished the tests with plenty of time to spare.

#### Assignments
At least in the term that I took the course, there was a significant difficulty spike between Assignment 1 and 2.

Assignment 1 was basically just translating a C program into MIPS assembly, and although it was a bit tedious, it was pretty easy to get full marks. The biggest challenge here was probably debugging in MIPS, as it can be more difficult to step through your code. However, print statements, autotest output, and the MIPSY command line tool were all helpful for this.

Assignment 2 was much more challenging, but also incredibly interesting and rewarding. It's generally related to bit maniupulation and files, and each subset of the assignment will scale in difficulty. I would recommend starting early on this assignment, as it can take a while to get your head around the spec. I also found it helpful to write out a plan for each subset before starting to code, as it can be easy to get lost in the details. This assignment probably improved my debugging skills more than any other course, and I would recommend using either `gdb` or setting up the VSCode debugger for C.


#### Exam
Although the exam for this course is extremely difficult to finish, attaining a high exam mark is fairly achievable if you have been consistently putting in the work through the term. This is because most of the exam questions resemble lab exercises or weekly tests. I would recommend doing the past papers and timing yourself, as the exam is comprised of mostly (if not completely) practical programming exercises.